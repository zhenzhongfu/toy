// 生成protoid.go,根据id构造对应的proto解析
// id，short类型，高8位区分mod，低8位区分msg
// e.g. ModLogin=1,ModLoginC2SLogin=1,最终id=0x0101=257
package main

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
)

const (
	OUTFILE = "protoid.go"
	PKG     = "//pkg:"
	MSG     = "//msg:"
)

func handleFile(filepath string, output *os.File) {
	// TODO 判断文件名
	if !strings.HasSuffix(filepath, ".proto") {
		fmt.Println("skip ", filepath)
		return
	}

	file, err := os.Open(filepath)
	if err != nil {
		fmt.Printf("Error: %s\n", err)
		return
	}
	defer file.Close()

	pkgid := 0
	br := bufio.NewReader(file)
	for {
		rawline, _, c := br.ReadLine()
		if c == io.EOF {
			break
		}
		line := string(rawline)
		if strings.Index(line, PKG) == 0 {
			// pkg
			// 拆解=
			fmt.Println(line)
			pkgid, err = strconv.Atoi(string(rawline[len(PKG):]))
			if err != nil {
				log.Fatal(err)
			}
			if pkgid > 255 {
				log.Fatal("pkg id overflow.", pkgid)
			}
		} else if strings.Index(line, MSG) == 0 {
			// msg
			fmt.Println(line)
			eqIdx := strings.Index(line, "=")
			key := string(rawline[len(PKG):eqIdx])
			rawmsgid, err := strconv.Atoi(string(rawline[(eqIdx + 1):]))
			if err != nil {
				log.Fatal(err)
			}
			if rawmsgid > 255 {
				log.Fatal("pkg id overflow.", rawmsgid)
			}

			//
			key = "Mod" + key
			msgid := pkgid*256 + rawmsgid
			newline := key + " uint32 =" + strconv.Itoa(msgid) + " // " + strconv.Itoa(pkgid) + "-" + strconv.Itoa(rawmsgid)

			fmt.Println(newline)
			if _, err := output.Write([]byte(newline + "\n")); err != nil {
				log.Fatal(err)
			}
		} else {
			// nothing
		}
	}
}

func gen(path string) {
	// 写protoid.go文件
	file, err := os.OpenFile(path+"/"+OUTFILE, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		log.Fatal(err)
	}
	defer func() {
		if err = file.Close(); err != nil {
			log.Fatal(err)
		}
	}()

	// package pb
	// const (
	if _, err := file.Write([]byte("//Code generated by genProtoID. DO NOT EDIT\npackage pb\nconst (\n")); err != nil {
		log.Fatal(err)
	}

	err = filepath.Walk(path, func(path string, f os.FileInfo, err error) error {
		if f == nil {
			return err
		}
		if f.IsDir() {
			return nil
		}
		fmt.Println("path: ", path)
		handleFile(path, file)
		return nil
	})
	if err != nil {
		log.Fatal("filepath.Walk() returned ", err)
	}

	// )
	if _, err := file.Write([]byte(")\n")); err != nil {
		log.Fatal(err)
	}
}

func main() {
	flag.Parse()
	root := flag.Arg(0)
	gen(root)
}
